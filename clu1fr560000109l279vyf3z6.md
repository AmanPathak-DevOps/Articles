---
title: "Advanced End-to-End DevSecOps Kubernetes Three-Tier Project using Azure AKS, fluxCD, Prometheus, Grafana, and GitLab"
seoTitle: "End to End Kubernetes Project"
seoDescription: "Advanced End-to-End DevSecOps Kubernetes Three-Tier Project using Azure AKS, fluxCD, Prometheus, Grafana, and GitLab"
datePublished: Thu Mar 21 2024 16:17:22 GMT+0000 (Coordinated Universal Time)
cuid: clu1fr560000109l279vyf3z6
slug: advanced-end-to-end-devsecops-kubernetes-three-tier-project-using-azure-aks-fluxcd-prometheus-grafana-and-gitlab
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1711028495653/088ce7b4-3508-4b46-98c6-40b2ab143489.gif
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1711037812833/cf4035c1-37e2-4b1d-abea-9d8cc3f868d2.gif
tags: cloud, docker, azure, kubernetes, cloud-computing, devops, gitlab, devsecops, hashicorp-vault

---

---

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1711028560202/cbf4933f-18a7-4acc-8056-8aba26a71d90.gif align="center")

### Introduction

In today’s rapidly evolving technological landscape, the deployment and management of cloud infrastructure are paramount for businesses striving for efficiency and scalability. DevOps practices coupled with cloud-native technologies offer a seamless approach to achieving this goal. In this blog, we delve into the intricacies of deploying a cloud infrastructure stack on Azure using Terraform and managing secrets securely with HashiCorp Vault. By leveraging GitLab CI/CD pipelines, we automate the deployment process, ensuring reliability and consistency in our infrastructure deployments.

### Objective

The objective of this blog is to demonstrate the implementation of a robust DevOps workflow for provisioning and managing cloud infrastructure on Azure. By employing Terraform for infrastructure as code (IaC) and HashiCorp Vault for secure secret management, we aim to streamline the deployment process while maintaining high levels of security and efficiency. Through a step-by-step guide, we provide insights into setting up GitLab CI/CD pipelines to automate the deployment and configuration tasks, empowering organizations to embrace modern DevOps practices effectively.

### **Pre-requisites**

* A foundational understanding of cloud computing concepts, particularly Azure services, Terraform, and GitLab CI/CD pipelines.
    
* Familiarity with Kubernetes and containerization principles.
    
* Access to an Azure subscription with appropriate permissions to create resources and manage secrets.
    
* Basic understanding of networking concepts and security principles.
    

![](https://lh7-us.googleusercontent.com/W50WmLEcxZ3zuQL8-XSd0tkdCaf9paNxsZZ_CaxHxmSQ09BEemY8NRFKJLkmqxkrJtSztusKH4BeeTt4ETMQRVk-izkosSDkL86XGBO9MC1sIYWnm4vZdzSeGLLt3BtgK5J_I_gCy07bVeftdqSg0W8 align="left")

Before going for the Workflow

Kindly, go through the above Hierarchical diagram which will give an overview of the Project Directory

Repository: [https://github.com/AmanPathak-DevOps/End-to-End-Azure-DevSecOps-Project](https://github.com/AmanPathak-DevOps/End-to-End-Azure-DevSecOps-Project)

### **Workflow:**

**Step 1:** We will create a GitLab VM on Azure Cloud with other networking services using Terraform.

**Step 2:** Once the Terraform script is ready, We will deploy the infrastructure using the GitLab CI Pipeline.

**Step 3:** We will create a HashiCorp Vault VM to store secrets on that server using Terraform, along with other networking services.

**Step 4:** We will deploy the infrastructure using the GitLab CI Pipeline.

**Step 5:** We will configure the HashiCorp Vault Server by creating roles, policies, and secrets (client ID and secret ID of Azure Account for Azure AKS).

**Step 6:** We are ready to create the Azure AKS Terraform Script.

**Step 7:** We will deploy the infrastructure using the GitLab CI Pipeline.

**Step 8:** We will work on the Source Code, starting with the backend.

**Step 9:** We will create a Dockerfile for the backend code.

**Step 10:** We will create a GitLab Runner for the backend repository and register it to run the pipeline on a self-hosted GitLab VM instead of GitLab-owned shared runners.

**Step 11:** We will generate the credentials of Azure ACR for the backend registry (a Dockerhub alternative).

**Step 12:** We will add the required variables in our backend repository.

**Step 13:** We will create the GitLab Pipeline.

**Step 14:** We will push our backend code, and the pipeline will start automatically.

**Step 15:** Now, we will work on the frontend Source Code.

**Step 16:** We will create a Dockerfile for the frontend code.

**Step 17:** We will create a GitLab Runner for the frontend repository and register it to run the pipeline on a self-hosted GitLab VM instead of GitLab-owned shared runners.

**Step 18:** We will generate the credentials of Azure ACR for the frontend registry (a Dockerhub alternative).

**Step 19:** We will add the required variables in our frontend repository.

**Step 20:** We will create the GitLab Pipeline.

**Step 21:** We will push our frontend code, and the pipeline will start automatically.

**Step 22:** Our next step will be to deploy the application on AKS, for which there are some prerequisites.

**Step 23:** We will install the Nginx ingress controller to deploy our application on AKS.

**Step 24:** We will configure the cert-manager to add an SSL certificate to our application.

**Step 25:** We will implement monitoring for our Kubernetes cluster using Prometheus & Grafana.

**Step 26:** Now, we will deploy our application on the Kubernetes Cluster. For that, we need to create manifest files.

**Step 27:** We will create manifest files for the Database, such as stateful sets, services, PV, PVC, and secrets.

**Step 28:** We will create manifest files for the backend, such as deployment and service.

**Step 29:** We will create a manifest file for the front end, such as deployment and service.

**Step 30:** Now, we will create our ingress file to deploy our application outside of the cluster with SSL.

**Step 31:** Once the manifest is created, we will automate CD, meaning whenever there is any change in the manifest such as an image update or anything, we don’t need to run the manifest file ourselves. For that, we will use fluxCD.

**Step 32:** We will install fluxCD on the Kubernetes Cluster.

**Step 33:** We will bootstrap the fluxCD, which will create its repository inside the Kubernetes-Manifest Subgroup named flux-config.

**Step 34:** We will create manifest-source and manifest-kustomization for each type of manifest, whether it’s database, backend, frontend, or ingress. This will enable automated CD.

---

### **HandsOn**

Click on **Groups**

![](https://cdn-images-1.medium.com/max/880/0*wKi4qEkH3CL0VVH9 align="left")

Click on **New Group**

![](https://cdn-images-1.medium.com/max/880/0*is_ztSpOTLuOKnIf align="left")

Click on **Create group**

![](https://cdn-images-1.medium.com/max/880/0*-37qObepB3mx2nHo align="left")

Provide the name of your **Group**

![](https://cdn-images-1.medium.com/max/880/0*ylmXEaYA2qrDRqGk align="left")

Click on **Create Group**

![](https://cdn-images-1.medium.com/max/880/0*oX14r-iVcdsgi8Ik align="left")

A group has been created

Now, we need to create a subgroup for each(Terraform, Source Code & Kubernetes Manifests)

Click on **Create new** **subgroup**

![](https://cdn-images-1.medium.com/max/880/0*kGMW_qSed6NnIaAV align="left")

Provide the name of your subgroup and click on **Create Subgroup**

![](https://cdn-images-1.medium.com/max/880/0*_bY_00Bf0RApUx1Z align="left")

As you can see our first **subgroup** has been created.

Now, we need to create two more subgroup within the Azure-DevSecOps-Project

![](https://cdn-images-1.medium.com/max/880/0*foZxdh-4PnXnsDxj align="left")

Here, we have created all three subgroups in our Azure-DevSecOps-Project Group.

I did not include the creation of the other two subgroups because it will be the same as we created in the previous step. So, don’t forget to do that

![](https://cdn-images-1.medium.com/max/880/0*eZzYiCLIocq293ti align="left")

Now, we will be going to work on our first **subgroup** which is **Infra-Code-Terraform** because to deploy any application or apply any manifest file we need infrastructure, right?

So, Let’s do that.

But before that, there is one important thing that we need to do.

We need to create a Personal Access token. So that, we will be able to clone the repo and push the changes.

As you observed, our Project is Private. So all the repositories will be Private.

We can generate Access tokens for each repo. But that feature is available in GitLab Premium. So, we will be creating our traditional Global Personal Access Token.

Click on Your Profile and then navigate to Edit Profile

![](https://cdn-images-1.medium.com/max/880/0*5cyr6bj3hY8Eb3vl align="left")

Click on **Access Tokens**

![](https://cdn-images-1.medium.com/max/880/0*8pPNL7gVxOnocdEH align="left")

Click on **Add new token**

![](https://cdn-images-1.medium.com/max/880/0*9vrYKgSrOrmZoc9n align="left")

Provide the name of your token and check the below boxes as shown in the below snippet and click on **Create personal access token**

![](https://cdn-images-1.medium.com/max/880/0*YpESIzHKHYaRnjVh align="left")

Copy your token and keep it somewhere, because we will be going to use that multiple times.

![](https://cdn-images-1.medium.com/max/880/0*iCeLvel7or5YnHkq align="left")

Now, get back to our Group and navigate to the Infra-Code-Terraform subgroup

We will be going to create three repositories

Click on **Create new project**

![](https://cdn-images-1.medium.com/max/880/0*n5jYNb3Ruu7X7j3p align="left")

Click on **Create blank project** to create the repository

![](https://cdn-images-1.medium.com/max/880/0*l1gjhEB1rnLvOLX6 align="left")

Provide the name of your project, as you know this repository will be dedicated to creating Azure VM. So, our Gitlab Pipeline will run on this VM instead of Shared runners.

Click on **Create Project**

![](https://cdn-images-1.medium.com/max/880/0*Vj95bghrF1FVWFb0 align="left")

Our first repository has been created.

**Note:** Don’t get confused if I am saying Project or Repository because both are the same in GitLab

![](https://cdn-images-1.medium.com/max/880/0*gJ_av_o8tl8T_nX7 align="left")

Now, to reduce the length of this blog. Kindly create two more Projects in the Infra-Code-Terraform subgroup which you can see below screenshot

![](https://cdn-images-1.medium.com/max/880/0*hpXyxFRONF8hgRZU align="left")

Before going to create infra from each repository, let’s see the prerequisites which we will be going to do in the next steps.

* We have configured the remote terraform backend. So, the tfstate file will be going to store on Azure Storage Accounts. We can also use the GitLab feature to store tfstate here only but for the current Project, we are going to keep our tfstate on Azure Storage Accounts.
    
* To create infra on Azure cloud, we need to store credentials in the GitLab variable.
    

Now, we are going to create an Azure Storage account to store our tfstate file there.

Go to the **Storage Account** in your Azure Account and click on **Create**.

![](https://cdn-images-1.medium.com/max/880/0*FhMPZondrGd_Bz4t align="left")

Initially, create a dedicated resource group for our tfstate file.

Click on **Create new** provide the name of your **resource group** and click on **OK**

![](https://cdn-images-1.medium.com/max/880/0*HUBlJyx8nv56inEp align="left")

Once you have created Resource Group, provide the unique name to create your Storage Account and click on **Review+Create**

![](https://cdn-images-1.medium.com/max/880/0*LCIBauv9alCUuJWs align="left")

Click on **Create**

![](https://cdn-images-1.medium.com/max/880/0*0XdozJBfluqX5Jur align="left")

Once the deployment is complete, click on **Go to the resource**

![](https://cdn-images-1.medium.com/max/880/0*frqfCv1catySjDPs align="left")

Now, we need to create a container inside our Azure Storage Account.

![](https://cdn-images-1.medium.com/max/880/0*P8z8B30vH_9FI9lJ align="left")

Click on **Container**

![](https://cdn-images-1.medium.com/max/880/0*OemG7jIC8mmI5Gtf align="left")

Provide the name of your **container** and click on **Create**

![](https://cdn-images-1.medium.com/max/880/0*kFk-abZa4aJAnFPA align="left")

Now, we have completed the setup for our terraform tfstate file

![](https://cdn-images-1.medium.com/max/880/0*5Elc7HwZCf1cZ7sr align="left")

Our next step is to add the credentials of our Azure Account in GitLab.

Below are the credentials that need to be added to the GitLab variables section

Right now, we have only Subscription ID & Tenant ID. Therefore, we need to generate client id and client secret.

***Note:*** *Client id and client secret are used to create service on Azure Cloud. It’s like you need to have permission to create something on Azure Cloud. Only Subscription ID and tenant ID would not be enough to do that.*

Let’s do that.

Search for **Entra ID** in your Azure Account and click on **it**

![](https://cdn-images-1.medium.com/max/880/0*p9Tz4zG3cS13pyok align="left")

Once, you land on the Entra ID page. Click on **App registrations**

![](https://cdn-images-1.medium.com/max/880/0*B-Tgb2YN8-EaO9AX align="left")

Click on **New registration**

![](https://cdn-images-1.medium.com/max/880/0*hzeZfo0ZALklDjPy align="left")

Provide the name of your **application** and click on **Register**

![](https://cdn-images-1.medium.com/max/880/0*QgySr8SF-mYlj2s- align="left")

Once you click on **Register**

You will be landed on the page that is shown in below snippet

![](https://cdn-images-1.medium.com/max/880/0*fmUYSsFsDRpUHzlt align="left")

Now, we have completed the app registration. But, the app must have access to our Azure Subscription to create services.

To do that, we need to provide an IAM role to the app that we registered in the previous step

Search **Subscription** in your Azure Account and click on **it**

![](https://cdn-images-1.medium.com/max/880/0*SBf_VwzLowon_AmC align="left")

You will be landed on the Subscription page

Click on **Access Control(IAM)**

![](https://cdn-images-1.medium.com/max/880/0*nbRVger_P7vonWnr align="left")

Click on **Add** and navigate to the **Add role assignment**

![](https://cdn-images-1.medium.com/max/880/0*qiABbJhDgvGzMgTR align="left")

In the role section, Click on **Privileged administrator roles** and select **Owner**.

***Note:*** *To give the Owner role to any app won’t happen in any Organization. This demonstration is for Practice purposes only. So, we are giving it Owner access*

![](https://cdn-images-1.medium.com/max/880/0*LSmPXFtFo_kPbXBV align="left")

Now, Go to **Members** and click on **Select members**

![](https://cdn-images-1.medium.com/max/880/0*_pHXTF2QTvMbmTJk align="left")

Search for the member name that you have provided to create app registration.

In my case, I have provided azure-devsecops. So, select that **member** and click on **Select**

![](https://cdn-images-1.medium.com/max/880/0*3_FlzlA9NYqNr0g2 align="left")

Click on **Conditions** Select the **second** **option** to provide decent privileges and click on **Review+assign**

![](https://cdn-images-1.medium.com/max/880/0*8ICpuQbwXItzzutI align="left")

Once, the role assignment is complete.

Navigate to the app registration in Entra ID and go to the app that you created earlier.

Click on Add a **Certificate** or **secret**

![](https://cdn-images-1.medium.com/max/880/0*Vjno8RRonY6nurZk align="left")

Click on **New Client secret**

![](https://cdn-images-1.medium.com/max/880/0*kySI3rHQbm9ta1qX align="left")

Provide the **description** and click on **Add**

![](https://cdn-images-1.medium.com/max/880/0*s6NI59YLYOOtith5 align="left")

Now, you have the **client's secret**

![](https://cdn-images-1.medium.com/max/880/0*bNg9ivoI0JCEMfFn align="left")

To get the **client ID**, navigate to the previous page and copy the **client ID**

![](https://cdn-images-1.medium.com/max/880/0*mxPfz04aS5ykWal2 align="left")

To get the tenant ID, go to **Entra ID** and copy the **tenant ID**

![](https://cdn-images-1.medium.com/max/880/0*4agXAM1Y439DEkhG align="left")

To get the subscription id, go to subscription and copy the **subscription id**

![](https://cdn-images-1.medium.com/max/880/0*TZXB9HNQrX-bMsmy align="left")

Now, we are set to add our credentials in GitLab Repositories for Infra-Code-Terraform.

Go to the **repository** and click on **CICD**

![](https://cdn-images-1.medium.com/max/880/0*UHlA0gOjGrgUqpHi align="left")

Now, add the below Key with the correct value that we received from the previous steps.

Try to check the Mask and Protected variables in flags while adding the variables. So, it won’t be shown in the output in the pipeline.

ARM\_CLIENT\_ID  
ARM\_CLIENT\_SECRET  
ARM\_SUBSCRIPTION\_ID  
ARM\_TENANT\_ID

![](https://cdn-images-1.medium.com/max/880/0*XiDJJp9t8D25K193 align="left")

Once, you add all four keys and values. It should look like the below snippet.

***Note:*** *You need these four keys and values in the other two repositories which are azure-hashicorp-vault-vm and azure-aks. Because we will create infra from that repository as well*

![](https://cdn-images-1.medium.com/max/880/0*vBHlSjj2Hc5NgcIB align="left")

Open the VS Code, and I will recommend you create the same directory structure as gitlab including group and subgroup to avoid any confusion

You can refer to the below snippet

![](https://cdn-images-1.medium.com/max/880/0*RhI1uvrEPx6uYHfg align="left")

Now, clone the **azure-gitlab-vm repository**

![](https://cdn-images-1.medium.com/max/880/0*zbHFf_96egNQnov5 align="left")

Navigate to the Infra-code-terraform directory on VS Code and run the below command to clone the repository

```abap
git clone https://gitlab.com/<your-gitlab-repo>.git
```

VS Code will prompt you for the username and password for GitLab. So, provide your GitLab username and the Personal Access Token that we have generated in the earlier steps

![](https://cdn-images-1.medium.com/max/880/0*t7Tv8hB0wW8AFiKY align="left")

In the below snippet, I have added the Terraform Scripts along with the gitlab-ci.yml file to automate the infrastructure deployment on Azure Cloud.

Kindly go through the Terraform Script and gitlab pipeline script. Feel free to modify it accordingly

![](https://cdn-images-1.medium.com/max/880/0*KAySjproOaY4cf_V align="left")

Before pushing these scripts to the GitLab Repository, there is one prerequisite which is the public key for our Azure VM.

Generate the public and private SSH keys using the below command

```abap
ssh-keygen
```

You can see in the left pane, the aman\_vm file is newly created. So, we will use a private key to connect with our instance

![](https://cdn-images-1.medium.com/max/880/0*HLEWR95Rie5eunLL align="left")

If you observe, we have private keys as well in the same repository and if we push the changes then the private key will also be pushed to the repo which is the worst practice.

Usually, Organizations keep their key in Azure Key Store but for now, we are keeping it in our local machine.

To do that, add a private key file name in your .gitignore file like below

![](https://cdn-images-1.medium.com/max/880/0*_OTb6EXZ6eSqiwsR align="left")

Now, push your changes to GitLab

![](https://cdn-images-1.medium.com/max/880/0*7UDdxan3fSbIKBAn align="left")

As soon as you push the changes to the repo, you will see in your GitLab repository that there is a pipeline created that was running and failed.

![](https://cdn-images-1.medium.com/max/880/0*jBfido1af6qZIi6c align="left")

Let’s troubleshoot the pipeline error

As you can see in the below error there is one white space added in the variables value which should not be added.

![](https://cdn-images-1.medium.com/max/880/0*7GsLmSXJq2CatY4j align="left")

Go to CICD navigate to CICD and edit the Subscription variable.

Now, some of you won’t get this error because you are perfect in copy and paste thing

![](https://cdn-images-1.medium.com/max/880/0*tlVQobPBxoDUO6gN align="left")

Now, we will run our pipeline again

Click on **Build** to expand the options and click on **Pipelines**

![](https://cdn-images-1.medium.com/max/880/0*LHpXprwtcHQxP8K9 align="left")

Click on **Run** **Pipeline**

![](https://cdn-images-1.medium.com/max/880/0*e5o7cHxQjEGvJHTj align="left")

Once you click on **Run Pipeline**, It will ask you for the **variables**.

So, if you went through the gitlab pipeline file you will have seen that I have added two variables which are TERRAFORM\_ACTION and ENV.

TERRAFORM\_ACTION is to provide whether the pipeline will create the infra or destroy the infrastructure where you have to either apply or destroy.

ENV is to provide the tfvars file, usually for multiple environments, we have multiple tfvars files. So, you can change the tfvars file name as well.

Right now, we want to create infra that's why I am providing apply as TERRAFORM\_ACTION and variables as ENV and clicking on Run pipeline

![](https://cdn-images-1.medium.com/max/880/0*EnH1RrqAPRNDfXqc align="left")

After the plan, the pipeline won’t run automatically.

As you know, both apply and destroy are critical. So, you need to see a blueprint which means what kind of services will be created or destroyed.

Once you ensure that plan is working according to you, then click on the **play** **button** which appears on the right of Running the Apply.

![](https://cdn-images-1.medium.com/max/880/0*DBfXuZQIpFZo6XsN align="left")

Now, you can see our pipeline has been created successfully

![](https://cdn-images-1.medium.com/max/880/0*WIdLMueB3jOk_Thk align="left")

Check the logs of the action job

As it is showing the services have been created

![](https://cdn-images-1.medium.com/max/880/0*DvBdMjm0s8Q3-J_5 align="left")

Go to your Azure Account and navigate to the Resource Group and you will be able to see all the services that are created by Pipeline

![](https://cdn-images-1.medium.com/max/880/0*UhXM_cjTERefZX6E align="left")

Once the GitLab VM is created. The main purpose of this VM is to run all further pipelines on this VM instead of GitLab shared runners.

This will be our self-hosted runner to run all the pipelines on our VM. This will ensure that security will be in our hands and if something goes wrong with the runner, we will be going to responsible for this which is one of the main advantages from the business perspective

To do that, We need to log in

Go to the Azure VM and select our created VM

![](https://cdn-images-1.medium.com/max/880/0*iT8d4S9RsN7163lP align="left")

Our username is Azure and public IP you need to copy from the above snippet.

To log in, you need the private key that we have generated

Run the below command to login

```abap
ssh -i aman_vm azure@<gitlab-vm-public-ip>
```

![](https://cdn-images-1.medium.com/max/880/0*d0dsipZ95cRa0w59 align="left")

Now, we need to install the Gitlab runner on our Gitlab VM to run all the pipelines from the VM

For that, you should know which repository’s pipelines need to run on your VM

Suppose, I need to create the hashicorp vault server and there is a pipeline I have created if I want to run the hashicorp vault server repository pipeline on a Gitlab VM. I need to go to the hashicorp vault server repository and the repository will give me a token to run the pipeline on GitLab VM.

Hope you understand the Gitlab Runners concept.

Before going to get the token, we need to install the runner. You don’t need to worry about that. GitLab provides the command in each repository to install the GitLab-runner.

To get the commands, Go to the azure-hashicorp-vault-vm repository navigate to Settings, and then click on **CICD**.

Click on **Expand** against **Runners**

Click on the **three dots** which are right on the **New project runner**

![](https://cdn-images-1.medium.com/max/880/0*oCIuTIIxcw8QARBw align="left")

In the above snippet, you have observed that on the left side, we can create our own Gitlab Runner and on the right side shared runners are available which are running pipelines

As our first task is to install Runner, click on **Show runner installation** and **registration instructions**

![](https://cdn-images-1.medium.com/max/880/0*mqA5y5GYv8Ui-OD6 align="left")

As our VM OS is Linux, we will use the below commands to install Gitlab Runner on our VM

Copy the commands of the first big box by clicking on a clipboard which is showing on the left

![](https://cdn-images-1.medium.com/max/880/0*QV4Ko631mFCNDcXL align="left")

Run the command on your VM

Don’t worry if you get the error like in the below snippet.

It means gitlab-runner already exists

![](https://cdn-images-1.medium.com/max/880/0*_128OdiPMugFSJrd align="left")

Check the runner status by the below command

```abap
sudo gitlab-runner status
```

![](https://cdn-images-1.medium.com/max/880/0*c7XppAurf18IlJwb align="left")

Now, the gitlab runner is installed. So, we are ready to register the runner to the hashicorp-vault repository

Go to the Gitlab repository from where you have copied the installation instructions

This time, you need to copy the command which is showing in the small box

![](https://cdn-images-1.medium.com/max/880/0*-VjdTSd2gviKr_bh align="left")

Run the command on your Azure VM

Once you run the command it will ask you some questions. You can skip all the questions except tags for the runner and Enter an executor which is highlighted in the below screenshot

***Note:*** *tags are the identity to run the pipeline on which runner, The tags are specified in the gitlab pipeline to run the particular stage on the particular runner and executor means that your runner will run the instructions that you have provided in the .gitlab-ci.yml whether it will be docker, shell, etc.*

![](https://cdn-images-1.medium.com/max/880/0*iz6MYOJUKXqegzxf align="left")

But, if we try to run our pipeline on this runner. It won’t run our pipeline because of one file which is .bash\_logout

To get rid of the issue, just change the file of .bash\_logout to something else

```abap
sudo su
cd /home/gitlab-runner/
mv .bash_logout .bash_logout_bkup
ls -al
```

![](https://cdn-images-1.medium.com/max/880/0*htlf_FjfeH_jZDNA align="left")

Now, Go to your **hashicorp-vault repository** and navigate to **runners**

If your runner is in green then Congratulations, your runner is perfectly added and now it can run the hashicorp vault pipeline on itself.

![](https://cdn-images-1.medium.com/max/880/0*WB6kUJTsPOShGoUK align="left")

So, our GitLab VM is configured. So, we will be going to deploy our next services which are related to HashiCorp Vault.

Hope you already added the required variables(Azure Credentials) which we did in our earlier steps. If yes, let’s go

Clone the repository on your VS code

![](https://cdn-images-1.medium.com/max/880/0*n8W8orgf_4IM1-XN align="left")

I have added the Terraform Scripts and gitlab pipeline script for the hashicorp server as well.

Kindly, go through the code

Also, I have generated the SSH files for the hashicorp vault server and added the public key name in the [virtual-machine.tf](http://virtual-machine.tf) file and the private key in the .gitiginore file

![](https://cdn-images-1.medium.com/max/880/0*ljtPSVPnOeT2guEH align="left")

Now, I have pushed the changes to GitLab and you can see the pipeline started

![](https://cdn-images-1.medium.com/max/880/0*0nWFr-Tq1ocSiVs5 align="left")

Our Pipeline was successful for the Plan. So, we can run the apply

![](https://cdn-images-1.medium.com/max/880/0*yhm-H-zTiefoEaax align="left")

Our application is completed

![](https://cdn-images-1.medium.com/max/880/0*glBSrMCY-cQ28lYm align="left")

Let’s see the logs by clicking on the action

![](https://cdn-images-1.medium.com/max/880/0*KSbKXxhKh9L6gqL0 align="left")

Let’s go to Azure Account and check the Resource Group to see the created services

The Services are available that we have created using Terraform

![](https://cdn-images-1.medium.com/max/880/0*n25DAV4u3_DGeOdV align="left")

Now, we need to set up our HashiCorp Vault server as we are going to store our client ID and client secret for Azure Kubernetes Secret

LogIn to HashiCorp Vault VM

![](https://cdn-images-1.medium.com/max/880/0*Cb3J16YG77keJRbP align="left")

Run the below command to start the vault in the background

```abap
nohup vault server -dev -dev-listen-address=”0.0.0.0:8200" > vault.log 2>&1 &
```

![](https://cdn-images-1.medium.com/max/880/0*RQO_Y3WHXuqqfg9R align="left")

To access the vault from the console, you need to have a Token which is stored in the vault.log file that is created by running on above command

```abap
cat vault.log | tail -10
```

Copy the Root token

![](https://cdn-images-1.medium.com/max/880/0*1JsOaSqeuyKLzHGw align="left")

Now, Access the Vault GUI by copying the Public IP of the Vault Server with port 8200 and pasting the copied Root token

![](https://cdn-images-1.medium.com/max/880/0*KuNk45xo7M8pTtWL align="left")

Once you log in, you will see UI like the below snippet

![](https://cdn-images-1.medium.com/max/880/0*Hrc1OeQx3PBgdpCg align="left")

Now, export the vault address by running the below command

```abap
export VAULT_ADDR=’http://0.0.0.0:8200'
```

![](https://cdn-images-1.medium.com/max/880/0*CexoseORg1WzpTd6 align="left")

We are going to keep the secrets in the vault server. So, those secrets should be accessible to authorized applications only.

To do that, we have roles and policies in the HashiCorp vault

We will create a role then we will create a policy that will bind with that role

Now, enable the approle to create the role

```abap
vault auth enable approle
```

![](https://cdn-images-1.medium.com/max/880/0*37C0rXnr4Ew0xSZx align="left")

Now, enable the secret to create secrets

```abap
vault secrets enable -path=secrets kv-v2
```

![](https://cdn-images-1.medium.com/max/880/0*IQaE_NjkpQeGEjco align="left")

In the Vault console, you can see secrets are present

![](https://cdn-images-1.medium.com/max/880/0*sskr-Sx_kbDKnqGO align="left")

Now, create a Secret by providing the path and then add your client ID and client secret credentials

![](https://cdn-images-1.medium.com/max/880/0*kwf89Qkonp9boxkz align="left")

The credentials are added

![](https://cdn-images-1.medium.com/max/880/0*cJb86KVrIOqU_WIf align="left")

Now, create the policy where we specify that the path of the secret can be only read by the app role

```abap
vault policy write terraform - <<EOF
path "secrets/access/*" {
capabilities = ["read"]
}
EOF
```

![](https://cdn-images-1.medium.com/max/880/0*ItosJp-uedJyxCKf align="left")

Now, create the approle and associate it with the policy that we have created above

```abap
vault write auth/approle/role/terraform \
secret_id_ttl=60m \
token_num_uses=60 \
token_ttl=60m \
token_max_ttl=60m \
secret_id_num_uses=60 \
token_policies=terraform
```

![](https://cdn-images-1.medium.com/max/880/0*JJZH2igcPCoC-idF align="left")

Now, we need the role ID which will help us to integrate with Terraform while creating AKS

```abap
vault read auth/approle/role/terraform/role-id
```

![](https://cdn-images-1.medium.com/max/880/0*EQCk5HdwTSnvrtKk align="left")

Now, copy the secret ID by running the below command

```abap
vault write -f auth/approle/role/terraform/secret-id
```

***Note:*** *If you get any error such as an invalid role or secret ID then delete the approle manually from the Vaut console and enable the approle, then create the approle with association of policy and get the new secrets and role ID by running the previous and current commands. This is happening because we have set the time to expire the role ID and secret it.*

![](https://cdn-images-1.medium.com/max/880/0*P5nwdFuPrHVWn3tz align="left")

Once, you get the role ID and secret ID. Then, add them to your AKS GitLab CICD Variables Section with proper keys and values.

![](https://cdn-images-1.medium.com/max/880/0*65qRh1avARlCgfgg align="left")

So, our HashiCorp VM is configured. So, we will be deploying our next service which is Azure Kubernetes Service.

Hope you already added the required variables(Azure Credentials) which we did in our earlier steps. If yes, let’s go

Clone the azure-aks repository on your VS code

![](https://cdn-images-1.medium.com/max/880/0*4e2w6F5codJOGM2G align="left")

I have added the Terraform Scripts and gitlab pipeline script for Azure Kubernetes Service as well.

Kindly, go through the code

Also, I have generated the SSH files for Azure Kubernetes Service Node Groups and added the public key name in the [virtual-machine.tf](http://virtual-machine.tf) file and the private key in the .gitiginore file.

Before going to push the changes and start the pipeline. I have added the Gitlab Runner as our Gitlab VM on azure-aks repository

AKS GitLab Runner Register

Keep the tags and executor as it is

![](https://cdn-images-1.medium.com/max/880/0*Be2a-LWXhQ6Byn4w align="left")

I have pushed the changes to GitLab and you can see the pipeline started

![](https://cdn-images-1.medium.com/max/880/0*LmDo2_fF7CS1AsOK align="left")

Let’s see the logs by clicking on the action

![](https://cdn-images-1.medium.com/max/880/0*fSmMSoo-zJOIqW1P align="left")

Let’s go to Azure Account and check the Resource Group to see the created services

The Services are available that we have created using Terraform

![](https://cdn-images-1.medium.com/max/880/0*S2O4yS-XOue0ddhv align="left")

Now, we need to set up our Azure Kubernetes Cluster on Azure GitLab VM where we installed runners

To do that, Click on Azure Kubernetes Service which is shown in the above screenshot

Click on Connect

![](https://cdn-images-1.medium.com/max/880/0*braApGUWuhwu6OO8 align="left")

Copy the first command and run it into your Azure GitLab VM

![](https://cdn-images-1.medium.com/max/880/0*iuwWGbY-xIXXrOva align="left")

We ran the command

![](https://cdn-images-1.medium.com/max/880/0*dNs-QkeQBZuW08u8 align="left")

Now, Copy the second command and run it on your Azure GitLab VM

You can validate whether your Azure AKS is working fine or not by running the below command

```abap
kubectl get nodes
```

![](https://cdn-images-1.medium.com/max/880/0*3PWPvDWIVrV1SpI- align="left")

Now, some prerequisites need to be completed for our Azure Kubernetes Cluster.

* We need to configure nginx ingress controllers to deploy our application on the internet.
    
* We need to configure Monitoring for our Kubernetes Cluster
    
* We need to configure SSL for our application
    

Let’s do it one by one

Install & Configure nginx ingress controller

Create the dedicated namespace for the ingress controller

```abap
kubectl create namespace ingress-basic
```

![](https://cdn-images-1.medium.com/max/880/0*b471dXEgRnPf1afg align="left")

Add the nginx controller helm repo and update the repo

```abap
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update
```

![](https://cdn-images-1.medium.com/max/880/0*vv--ruUjzhy6faHI align="left")

Before running the next command, Go to Azure Account search for Azure Load Balancer, and click on it

![](https://cdn-images-1.medium.com/max/880/0*k294TLmBDtqR9t1W align="left")

There can be many load balancers if you have created if the load balancer name is Kubernetes click on it

![](https://cdn-images-1.medium.com/max/880/0*eBqH6WqRPjaGcAld align="left")

Once you land on the Kubernetes load balancer page, Click on Frontend IP Configuration and copy the IP address

![](https://cdn-images-1.medium.com/max/880/0*5k8tmIPSUdgXMk3A align="left")

Now, we need to install the helm chart but in the below command don’t forget to replace the &lt;PUBLIC-IP&gt; with your copied Public IP that you have done in the previous steps

```abap
helm install ingress-nginx ingress-nginx/ingress-nginx \
    --namespace ingress-basic \
    --set controller.replicaCount=2 \
    --set controller.nodeSelector."kubernetes\.io/os"=linux \
    --set defaultBackend.nodeSelector."beta\.kubernetes\.io/os"=linux \
    --set controller.service.externalTrafficPolicy=Local \
    --set controller.service.loadBalancerIP="<PUBLIC-IP>"
```

![](https://cdn-images-1.medium.com/max/880/0*Om7BUIkm1EOG9pwg align="left")

To validate whether ingress is installed or not run the below command and make sure all pods must be running

![](https://cdn-images-1.medium.com/max/880/0*EXmMLXNdt5mfaYHD align="left")

Now, we will be going to configure Monitoring in which we will use Prometheus and Grafana

To do that, create a namespace for Prometheus

```abap
kubectl create ns prometheus
```

![](https://cdn-images-1.medium.com/max/880/0*eZzYiCLIocq293ti align="left")

Add the Prometheus helm repo and update the repo

```abap
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update
```

![](https://cdn-images-1.medium.com/max/880/0*mFUGWJfKynH2BY0f align="left")

Install the Prometheus Helm chart

```abap
helm install prometheus prometheus-community/prometheus -n prometheus
```

![](https://cdn-images-1.medium.com/max/880/0*P0VQU6O29GoLzjhN align="left")

We need to deploy our Prometheus server to the external world

To do that, we will be going to change the service type of Prometheus Service from NodePort to LoadBalancer

Firstly, let’s check the services

![](https://cdn-images-1.medium.com/max/880/0*YLhPIbTy-NCmxyUe align="left")

Run the below command to expose the Prometheus service outside of our cluster

```abap
kubectl expose service prometheus-server --type=LoadBalancer --target-port=9090 --name=prometheus-server-ext -n prometheus
```

Once you run the command, the Prometheus will be able to access from outside of the cluster

Run the below command to get the external IP to access prometheus

```abap
kubectl get svc -n prometheus
```

![](https://cdn-images-1.medium.com/max/880/0*-deYBZ8KRhnwO7Ij align="left")

Copy the Public IP of Prometheus server and hit it on your favorite browser to access the Prometheus Server

![](https://cdn-images-1.medium.com/max/880/0*kcjr1NwNv54Fd5a3 align="left")

Now, we will configure grafana to visualize the details of our Kubernetes Cluster

Create a dedicated namespace for it

![](https://cdn-images-1.medium.com/max/880/0*TmA0QEzkWYmxnCG- align="left")

Add the Prometheus helm repo and update the repo

```abap
helm repo add grafana https://grafana.github.io/helm-charts
helm repo update
```

![](https://cdn-images-1.medium.com/max/880/0*ULOTDxBfWQ_P89GO align="left")

Install the grafana helm chart

```abap
helm install grafana grafana/grafana -n grafana
```

![](https://cdn-images-1.medium.com/max/880/0*GIqhXPk2zklMsVwA align="left")

Now, expose the Grafana server to the outside of the cluster

```abap
kubectl expose service grafana --type=LoadBalancer --target-port=3000 --name=grafana-ext -n grafana
```

Run the below command to get the external IP to access grafana

```abap
kubectl get svc -n grafana
```

![](https://cdn-images-1.medium.com/max/880/0*A8xlNkJzRwQRMs_T align="left")

To access the Grafana dashboard, you will need a username and password.

To get that run the below command to get the password and username will be the admin

```abap
kubectl get secret --namespace grafana grafana -o jsonpath="{.data.admin-password}" | base64 --decode ; echo
```

![](https://cdn-images-1.medium.com/max/880/0*lzeAoijQzFdOc-8G align="left")

Copy the Public IP of the Grafana server and hit it on your favorite browser to access the Grafana server and provide the password that we received after running the previous command

![](https://cdn-images-1.medium.com/max/880/0*PF_yWevcbixgiXz8 align="left")

Once you log in, you need to add the Data Sources to monitor your Kubernetes Cluster

Click on **Data Sources**

![](https://cdn-images-1.medium.com/max/880/0*F6zl8lQ546udw-Jl align="left")

Click on **Prometheus** as a **data source**

![](https://cdn-images-1.medium.com/max/880/0*CcdlV1CB-k8q_8sj align="left")

Provide the Prometheus server URL like the below snippet and click on **Save & test**

![](https://cdn-images-1.medium.com/max/880/0*LPf-mKM_w9Fz1zJ- align="left")

Now, click on **Dashboard** which is showing on the left

![](https://cdn-images-1.medium.com/max/880/0*NnpnTyPuMdegwfps align="left")

Click on Create **Dashboard** to create a custom dashboard

![](https://cdn-images-1.medium.com/max/880/0*TOGT6qom0JmTxLFA align="left")

Click on the **Import dashboard**

![](https://cdn-images-1.medium.com/max/880/0*qn5hHOiJff2KPg6L align="left")

Provide **6417** ID to import dashboard.

6417 is the unique ID that has Kubernetes data to visualize it on the Grafana Dashboard

Click on **Load**

![](https://cdn-images-1.medium.com/max/880/0*3LHx1JGwKzSQ2fDL align="left")

Once you land on the dashboard, select the data source as Prometheus that we configured in the earlier step and click on **import**

![](https://cdn-images-1.medium.com/max/880/0*PQ4kxNsisXbgRvb3 align="left")

Here you can see the **dashboard**

![](https://cdn-images-1.medium.com/max/880/0*3KzdTzZPPNsRxJmA align="left")

Monitoring is Done for now

Now, we will configure the SSL certificate for our application which will be deployed in the next 1 hour

Run the below command to label ingress-basic validation=true

kubectl label namespace ingress-basic [cert-manager.io/disable-validation=true](http://cert-manager.io/disable-validation=true)

![](https://cdn-images-1.medium.com/max/880/0*4FAa-2yCO5fXeFfm align="left")

Add the cert manager helm repo and update the repo

![](https://cdn-images-1.medium.com/max/880/0*-1uyYLlFmpMQ-Hcq align="left")

We need some Custom Resource Definitions to configure SSL for our application

Run the below command

```abap
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.7.1/cert-manager.crds.yaml
```

![](https://cdn-images-1.medium.com/max/880/0*Ga6iN4dp3DfKX5hF align="left")

Install the cert manager helm chart

```abap
helm install cert-manager jetstack/cert-manager \
  --namespace ingress-basic \
  --version v1.7.1
```

![](https://cdn-images-1.medium.com/max/880/0*23K54zbtNrcmXKJp align="left")

Validate whether cert-manager pods are running or not

![](https://cdn-images-1.medium.com/max/880/0*XwMBuBLacH1vjcUH align="left")

There are two more things we need to implement SSL

The first one is cluster issuer where we will deploy SSL configurations

The second is to add annotations and tls config in the ingress file

This will be done automatically using fluxCD where fluxCD will deploy these both files itself.

Finally, we are going towards our Source Code deployment as we have configured for Terraform

Now, we need to build our Image of our Source Code which is frontend and backend

But Before going there, we need to create projects on our GitLab

Go to Source-Code-Build Sub-group

![](https://cdn-images-1.medium.com/max/880/0*msuY2Nac1HNT7Nly align="left")

Click on Create New Project

![](https://cdn-images-1.medium.com/max/880/0*pX27k18xWh4bBhtc align="left")

Provide the name to your repository as we need to create two repository frontend and backend

Click on **Create project**

![](https://cdn-images-1.medium.com/max/880/0*YeQsfbT8B44XHpOx align="left")

Now, create one more repository for frontend and in the end, it should look like the below snippet inside the Source-Code-Build subgroup

![](https://cdn-images-1.medium.com/max/880/0*nq1xrELnyw5SZiIi align="left")

We are going to start work on the backend repository first and it will be 90 percent the same as compared to the frontend. So, take a chill pill

Clone the **backend repository** in your VS Code

![](https://cdn-images-1.medium.com/max/880/0*f4DsB79k12N2mU3I align="left")

I have added the code for the backend along with Dockerfile and gitlab-ci.yml

Kindly go through at least the Dockerfile and gitlab-ci.yml file

![](https://cdn-images-1.medium.com/max/880/0*gca5AkUpbtTerMfo align="left")

Before going to push our code to repo, we need to set up the Sonarqube

So, If you go to Azure Gitlab VM, run the ‘docker ps’ command and you will be able to see one container is running which is sonarqube

This thing we have done while we creating Gitlab VM using Terraform

***Note****: Refer to the* [*tools-install.sh*](http://tools-install.sh) *file for validation purposes*

![](https://cdn-images-1.medium.com/max/880/0*aEPBddS7c8pPS6rV align="left")

Copy the Public IP of your Gitlab VM and paste it on your favorite browser with Port 9000

The username and password will be **admin**

![](https://cdn-images-1.medium.com/max/880/0*MQWzwG_zgu0bzBKB align="left")

Regenerate the password

![](https://cdn-images-1.medium.com/max/880/0*WVWB5RSknSWSAUMF align="left")

Now, we need to create a project for Code Analysis for our backend code

Click on **manually**

![](https://cdn-images-1.medium.com/max/880/0*bbZ_mxGjgBtHxwyq align="left")

Provide the name of your project and click on **Setup**

![](https://cdn-images-1.medium.com/max/880/0*0zdjA4QoQmCjrNdw align="left")

As we are using Gitlab, So click on With **GitLab CI** for analyzing the repository(backend)

![](https://cdn-images-1.medium.com/max/880/0*Rt5guGTCzElxG0I0 align="left")

Select **Other** as the Project key

![](https://cdn-images-1.medium.com/max/880/0*dQhmPQrDMP1NVAjo align="left")

Now, you will get one instruction in which you need to create a file named [sonar-project.properties](http://sonar-project.properties) and copy and paste the content where your backend code is located

![](https://cdn-images-1.medium.com/max/880/0*jdjojl3iVJg8vGkg align="left")

I am adding the file and content from the VS Code

![](https://cdn-images-1.medium.com/max/880/0*es-cvCBFK2iJVbcT align="left")

Go Back to your Sonarqube and click on **Continue** if you don’t  
Now you need to generate the token and add it to your backend Gitlab repository

Click on **Generate a token**

![](https://cdn-images-1.medium.com/max/880/0*9xVtoE89V-uRJzAh align="left")

Click on **Generate**

![](https://cdn-images-1.medium.com/max/880/0*NT-v2Wvo8bDuPLT5 align="left")

Copy the token and click on **Continue**

![](https://cdn-images-1.medium.com/max/880/0*W0q1IhWRU_zTfK5K align="left")

Now we need to add the token on our backend Gitlab repository

Keep the key name as it is

![](https://cdn-images-1.medium.com/max/880/0*RcoS0-cekzoGUk7V align="left")

Now, we need to add a sonar host URL variable in our backend Gitlab repository

Go back to your sonarqube and copy the value provided by the sonarqube

![](https://cdn-images-1.medium.com/max/880/0*gtuQkFp8Br6nFaqL align="left")

Now, Go back to your Sonarqube and click on **Continue** after adding both variables

You will see a long file which is a code-analysis stage to add it to your .gitlab-ci.yml

This will perform the code analysis on your backend code

Copy the content

![](https://cdn-images-1.medium.com/max/880/0*zck1clcBEZh1HPI2 align="left")

Paste it in your .gitlab-ci.yml

After the sonarqube-check line, stage you need to define yourself because that will be eliminated from the side of the sonarqube

So don’t forget to do that and for more reference, you can see my .gitlab-ci.yml file which looks into the third line of the script

![](https://cdn-images-1.medium.com/max/880/0*rOOCYsdiBQzprry7 align="left")

Here, we completed the setup of Sonarqube for our backend code. The same thing we will be going to do for the front end as well. But that will happen once our backend pipeline completed

![](https://cdn-images-1.medium.com/max/880/0*HBteen3ZiYRfjT4o align="left")

Now, we need to add some variables that are needed for our backend code repo

The first one is to add the Azure Container Registry credentials because once our docker image completed the build then, we will be going to push our docker image to Azure Private Container Registry

If you went through the code of azure-aks repo, you must have seen that we have created two Azure Container Registry named backend and frontend

Go to your Azure Account and search for **Container Registry** then click on it

![](https://cdn-images-1.medium.com/max/880/0*q6blC-wg0sdd91cU align="left")

You can see the Azure Container Registries are present

![](https://cdn-images-1.medium.com/max/880/0*XHmeN5cjDD7vl-cn align="left")

Go to your backend registry

Now, we need to generate the Access keys for our backend registry because we are working on Private ACR

Click on the **Access keys** showing in the left pane

![](https://cdn-images-1.medium.com/max/880/0*v_mOavglpjXXFR4j align="left")

Click on the **checkbox** of Admin user

![](https://cdn-images-1.medium.com/max/880/0*FzL53FpZoxu3_Rf9 align="left")

Once you fill the checkbox, you can see the password for our ACRs

![](https://cdn-images-1.medium.com/max/880/0*d-AIOyEHgIKNCvsP align="left")

Now, we need to take three values for our GitLab repo variables which are username, login server, and password(any password will work)

So, copy the given values for each variable name and paste it into your GitLab backend repo’s variable section

***Note:*** *Keep all the key names as it is if you are not going to change anything in your .gitlab-ci.yml file. Refer to the below image and take a look at each key and value for CICD variables*

![](https://cdn-images-1.medium.com/max/880/0*gQRNxHoGLdRNXZp1 align="left")

Now, we need to add docker username and password(PAT) CICD variables in our Gitlab backend repo

For Password, we need to generate PAT and I am hoping that you have an account on Dockerhub. If not, please create it

Login to your Dockerhub account click on your **Profile** then click on **My Account**

![](https://cdn-images-1.medium.com/max/880/0*iVwI4mKOtsqKKf0m align="left")

I have already generated the token, you can generate it by clicking on **New Access Token**

![](https://cdn-images-1.medium.com/max/880/0*vOJEHQ9SPUrUQmOi align="left")

Describe your Access Token and click on **Generate**.

![](https://cdn-images-1.medium.com/max/880/0*m4ii7Q8nTxCIGnab align="left")

Then, you will get the token.

**Copy** the token and paste it which we are going to do in the next step

![](https://cdn-images-1.medium.com/max/880/0*iZRHixlUiUtAwIUk align="left")

Now, we have added some other CICD variables which are Docker username, password, and Gitlab token(We have already generated in the first few steps of this blog).

![](https://cdn-images-1.medium.com/max/880/0*P01ASfmd66gNHkW6 align="left")

Now, we need to add two more variables which are GITLAB\_ID(your mail ID which is registered to your gitlab) and GITLAB\_USERNAME

Once you added the variables, the final snippet can be seen below

***Note****: Kindly add all variables as shown in the below screenshot*

![](https://cdn-images-1.medium.com/max/880/0*Uet3H76QF8DzS_PJ align="left")

Now, before going to push our code to the repo. We need to configure that our backend code should be built on the Gitlab VM

To do that, Go to **CICD** and navigate to the **Runners** section in Gitlab Backend Repo

Click on **three dots**

![](https://cdn-images-1.medium.com/max/880/0*2UXsnRy7fRh0qVdZ align="left")

Click on **Show runner installation** and registration instructions

![](https://cdn-images-1.medium.com/max/880/0*ZVvei_U4JRGT8Cma align="left")

We have already installed the run on our Gitlab. Now, we need only the gitlab repo token to integrate it with the Gitlab VM

Copy the below command

![](https://cdn-images-1.medium.com/max/880/0*gcI8MRF7pkrquX_u align="left")

Run the copied command on your GitLab VM

It will ask you some questions, so while it will ask for tags then provide **backend** as tag, and when it asks for Enter an executor, provide a shell for now

![](https://cdn-images-1.medium.com/max/880/0*yXFLnQ1XoPWwK9pY align="left")

Once, you followed the above steps. Go back to your Gitlab backend repo’s Runner section

You will see your Runner comes in Green Signal which means you can run your Pipeline on this runner

***Note:*** *If your runner is in stop status, wait for two to three minutes and still the runner is not coming in the green state then start the gitlab runner by using the command ‘sudo gitlab-runner start’*

![](https://cdn-images-1.medium.com/max/880/0*ztY5OBouZr3fjmxi align="left")

Now, we are ready to push our backend code to GitLab repo

![](https://cdn-images-1.medium.com/max/880/0*raEgPV7ik5MOaVfK align="left")

Code is Pushed and the Pipeline is started

![](https://cdn-images-1.medium.com/max/880/0*kVoz_rO_GJ6G-NkB align="left")

We will get an error that the repository is not found because we have not created a manifest repository in the Kubernetes-Manifests subgroup.

Let’s do it now

Go to your GitLab Group and click on **Kubernetes-Manifests**

![](https://cdn-images-1.medium.com/max/880/0*pY91jApNEKJAOVL6 align="left")

The repository should look like this

![](https://cdn-images-1.medium.com/max/880/0*7n5ltOExO8ZHUcOO align="left")

Now, we need to push our manifests file to this repository

I have cloned the manifests repo and added all manifests file

***Note:*** *If you are new to Kubernetes. Don’t panic at least try to read some manifest because you will get a high overview of what we are going to do. One more thing, change the username and repository for frontend deployment and backend deployment because it will be different according to your ACR registry name and username.*

![](https://cdn-images-1.medium.com/max/880/0*c5qDNQl-nGr70ZJ7 align="left")

Now, I am pushing all the manifest files to the repository

![](https://cdn-images-1.medium.com/max/880/0*sw9yEQIZV6g1WujV align="left")

We are ready to run the pipeline but before going to do that, please check the docker image tag before running the pipeline because once the pipeline gets completed then you will see the tag will be changed

Now, run the pipeline again manually

Once, the pipeline reaches the last stage in the deployment file needs to be updated.

You need to run it manually because this will trigger the deployment of the manifest file(which will be implemented in the next 20 minutes)

So, click on **Play**

![](https://cdn-images-1.medium.com/max/880/0*IJhGYVmxWw_HYRru align="left")

Pipeline is Successful

![](https://cdn-images-1.medium.com/max/880/0*BFaxxeJQpjiiWwQD align="left")

If you go to Pipeline, you will green mango and red mango which looks so cool, right?

![](https://cdn-images-1.medium.com/max/880/0*LEG6MQbaxLG2ZZ_- align="left")

Now, Go to the manifest repo under the Kubernetes-Manifests sub-group and navigate to the Backend deployment file

You will see that the deployment file updated the image version to 3

![](https://cdn-images-1.medium.com/max/880/0*tsTrFJnnzpTByYMQ align="left")

If you go to Sonarqube, you will see that Sonarqube also completed the analysis of the code

![](https://lh7-us.googleusercontent.com/kWkB-ow-f0jktiDu08nBwVIDIHMfmcyclAKU_Hf-XsSJraj__WCLzwXTOhf41mb8qPQkDeKGI1Xa0HVyP1o0rzBnYBusN9IMHA2UiQ-0aaIwEq4-ttSJQitjQs_Rgoi2BAHu1kxbmzHrRZyY0LH6cFw align="left")

Backend is completed and now It’s turn for Frontend.

Don’t worry it won’t be that much because 90 percent of steps are similar to the backend

So, Let’s do it

Clone the frontend repository in your VS Code

![](https://lh7-us.googleusercontent.com/5SYCm4vimlfyUG_y3rOrU91Kr2lUvglYY0eJgryfBS2TuV4SgoQXsWRElyhJvi4mWHYvzP6OIFJ1B5WIdQZ98BoRTpUY4KdPT3-3W8aLEGinU6J7EeY3msTOvEEzHODdDtCklUH65H2Cd_pdowp56GI align="left")

I have added the code for frontend along with Dockerfile and gitlab-ci.yml

Kindly go through at least the Dockerfile and gitlab-ci.yml file

![](https://lh7-us.googleusercontent.com/ahkpC-mjfhUbbx09LADlCLN1L0LmN74V16zhFWjAzkJHykt7EECsGOsRapYg03Mkp0XeKjSjqO1ctJGJoRqS1c5qp_ndZkWA3NQW1mDGWFNBpjHgslVf40VNMAONUXZxQmLNsui2bvAv_TO9YnPbwWY align="left")

Before going to push our frontend code to the repo, we need to set up the Sonarqube for the frontend

Go to Sonarqube and click on **Projects**

![](https://lh7-us.googleusercontent.com/74sYP1wnnkJYDHgcwTQJIpLr8oFNpVf1Brh8dwtLFJN1_RyG-AKIdM_X5dw_D6IrQTX6alGR2qgVTqHzvVfJrvXouDj3vl4Q4c-FqeOGAuNHS23BC6OslX3h47Ow-JrMgYIueWkUmcEq9D9su5l4FVw align="left")

Click on **Create Project** and select **Manually**

![](https://lh7-us.googleusercontent.com/Hh0_Q8hZz0DbkWZc9BxHP2fWZv2MD3-NQ9mhiQz0iZGg8Jn_yiYL1ORr9O1h9LqO7rZ8bOd-JluOK-ecWCRBV3sDrpibpInb0JyNY5vTBWjKOxv8Jn3HCM0w3NumO-R_yMAEb-jx-tJh3-DruqqML9o align="left")

Provide the **Project name** and click on **Setup**

![](https://lh7-us.googleusercontent.com/aPC6viARPWaKnb2gMVHa8qH8pQGYczSd2uIlyqRlvMdLzJK58NB_x9vFROiocmDJtkOGGH2gcSItaFoFH-A668yxcal57whK9HPekSXtH9xLzG1MgU92WeJMGwdQvbiFijydS31Yyd0c8CqMowGKPSU align="left")

Select **Gitlab CI**

![](https://lh7-us.googleusercontent.com/sa-kWyjansh0ppaTBzi6ru1XPkuwzG7WwuX7V0pGr3dmJGSesxRudwkxuEMD-2tGTadFNZ3qLGojMhOqSzT5Io4HnE3yVMfUSpJkhOxFiO-lvofGRjKidUKe14tr62VAcsrC61jYMF11EsWE9sJKY6U align="left")

Select the Project key as **Other**

![](https://lh7-us.googleusercontent.com/bL3y5Kh6SM-52yy_0WeC8n-JxNRkiP9vtwHs6jJVzHRE-PnLep7ZwrVc6Ho0ygY1unYnGD7CsjhsIRFtNUw4ja3_wqT_RBRCp5vmst9iB2LAV2Ft2bmjB0fZeJwGZQ5RPwWnkHvHxceIsCb-WOUUULQ align="left")

Create the file in your frontend repository which is shown below in the snippet and copy and paste the content in the given file as well

![](https://lh7-us.googleusercontent.com/BSnNAXmlmbtNOmQ8EoZLTx_KRANlhRlgnd1mn2BoCT-IcJGe3ZW-1U_lp_9lm0UniP7bKjD8uBr8QGM64gXCzjCxGopLX-8cqW8KuWwDRbTjR5XTrBtzrgWuXqzHh3gt6-2C4FvLca1GJGqEz2upS84 align="left")

You refer to the below snippet

![](https://lh7-us.googleusercontent.com/K38MsI7jI8PgOZ51eP9evIbV5ozgSOBl7TR1eS5mx5UajSUP4bOjMVFMYf9o2A3fkHKUlFYf0M5SEj3WELtp1KlXPoLkiHLaVMQ4Y08cO0do3WdkuegRM18KkMUW6ZTPKy1dIesMto5GFUF9ZHmALlg align="left")

Generate the token and paste them in the frontend repository CICD variable’s section as we did for the backend and do the same thing with the host URL as well

![](https://lh7-us.googleusercontent.com/jT3hAPKm2VISlZPbU2zoZ4hBDGARMg2WamztEZiOehhmglDfdVmmgqBViwjQ55Uu58_CKAFk4xVxsmPEAgsrV0xn7phpAsFTDkkLSVUkxll-903pY27Ujw7pnetYIrt_rgng_WvdyQdcArmlvY_D-bc align="left")

Click on **Generate** to generate the token

![](https://lh7-us.googleusercontent.com/ZoGaqxcwPg1TZ9qeyLat5qUAHglV3p7PY19zYEJgQiPx4I-i75GLluc6vM32VbeFdUPAKHPHs_HFMKCpA1gtrWMDbv7YrdppIDXN1a28FLm5NAcVUwDt5QEYgnkJPYsMUescy3piipCOPeVJinqXOD8 align="left")

Copy the token keep it safe somewhere and click on **continue**

![](https://lh7-us.googleusercontent.com/jpMjy-qJiXSj8tVE4YAHCni0CIGH5YaMbwFXak7w_EKhSyWxfpG-9K_xb78ZZqfWXmhy2uLKjC75Q6BR_Z6FY2zyR0mnu9ncN1fzLc1OPFvqq81lt5hKCJNIVPV4Ju3Q0yY8Ua5_XtARPkDb175Oeg8 align="left")

After adding both variables, it should look like the below snippet

![](https://lh7-us.googleusercontent.com/3C77xi3jChcR4wRqYmawussYfbg7l5SPMq-fvwZhKRMTjPBFVk3tFRfNr1RJJIfHPK8srUNXn3pfw6PaUBDnF-iiEpFZD1cEPxxI3VEz20FBe4M5suvUPIPjOEPM5A7hsL_xJmnhZ0YA53TbWmad5Mo align="left")

Copy the content for the gitlab-ci.yml file and paste it into your .gitlab-ci.yml file

![](https://lh7-us.googleusercontent.com/zIh4480BboXfFfWGvorEU2DTprzqXWGVKuzZNTvcW8LCAaU1K6eNH1ZvfmMnnCPRtKCqwzHZ41wHFolQCjZeKYXPBBJpr9R9ZpzwPvH3h_HTe3LhIuicSlhECpsQhJlHx1XQpkuOjzu0kXQDrbPE4Ac align="left")

You can refer to the below snippet

![](https://lh7-us.googleusercontent.com/kHImulgq5oqEG4woqBnbk_dW07aRX6UEyc1HWrA9z5P4NYlRlc9_0JsLG1J8yMktnlby9Fvz3my3peSI1uMyOiKTtz7opdhm1zZa3YmTyul-3al1Fv6O38k9lMy2-4A6RA4LE4aLgmM_pqsZII3TmKY align="left")

We have completed the setup for our frontend Sonarqube Project

![](https://lh7-us.googleusercontent.com/UOlLi3NnpUfZoD1jM9x-YvE260I71m5_z9_cGj_0DKC68mhbHgwbmbt76yPh4Fzs9_VJHdOWySE5R21m-FWPZo7ic-SrzAaXQVrnHDoxf1k4-44Kv5TcGxTILwhWYFV5ByXtBgbGPNz6_yRpJOirIgk align="left")

Now, we need some more variables as per our requirements

Generate the credentials for Azure ACR frontend registry

![](https://lh7-us.googleusercontent.com/JJ6a8smkbQNGAOv6rRV3T1WLD5UwZgipRyaqzreMdJUK9bcU-vAJpgrRNNe0gYGZoHiIkt8JkIkpAakKgTKd_Z_C8PpTMC0GJ_2539AwzygNvpASxykBTx0MyB-GM8h277vgI4i4zCJC2MGTJKZ0OXk align="left")

Fill in the Admin user Checkmark to generate the username and password for ACR

![](https://lh7-us.googleusercontent.com/tQxI6teOgSpwvk6fGf1c85tzNqIPt-nOViP4CaAp6klol6Hie8if35tH_dqc3ECxu6maJsXPyNmO1rfCAYUkJq_2xgDEv8fVQJOLq3l5ID8fyXw2t861VGiGMf5eIdqjLYgJqnYvOh_nkw-eNQYXd64 align="left")

Then, add the variables according to the below snippet

![](https://lh7-us.googleusercontent.com/JF71YgWnm9vcRbTyu5OKIiyOz3itvIQhFP_AgACt5z7nAyggbCxKi6LqTKYOb6dYqMKDMdbFnZajbbCQ-PkhguXwXx17EMxk9RWwR3OF6cYURCw1iBitS92kmdD7jc_r80wH5D_kotc1PpRei_UIWgs align="left")

We need to add other credentials as well in our frontend repository CICD variable’s section such as Gitlab token, Gitlab mail ID, Gitlab username, Docker username, and Docker password

Refer to the below snippet

![](https://cdn-images-1.medium.com/max/880/0*wAt46JLAbyNB4mFt align="left")

Now, I want my front-end code to be built on a Gitlab VM.

To do that, I need to register my frontend repository with Gitlab VM

Click on **Show runner installations** and registration instructions

![](https://lh7-us.googleusercontent.com/YiKMFqt1tdVLb0X7aqyCH0ijymclHx1URFVEEhP-fnG-R0Md6_1OG-ydSpbTDT9TcXjB1GVUbh-ggNNlUDrDTxQF5Hrfyas9BYEktkZUUsNWU4e1e7HIX2HqVxojI49dXSJhMce3IxHAduGP89WT4D0 align="left")

Copy the last command to register

![](https://lh7-us.googleusercontent.com/rWdPuXvxlXoSyT3HeqH4R1GDGgmsC06kwiWsORax8YPsVKdqutPECpAt7FGQVmsPuLd7RjGGUUa0JU16QHnWeksNA2OjBPGExpH9NZakHiT5npWjGQ9X9xF73PaHJ2ZJtdjNThnni5BFqBSSWPTG3rM align="left")

Paste the command and provide frontend in tags and shell in the executor

![](https://lh7-us.googleusercontent.com/JRaa7vZJvRYZ6m29rLya_KgkUdAMVSUsO04Fl5GjlkrHce6AfusAj1vc1qN0aqYyNGKQDSVK73jpfgeSTyaUsb1hE4YIdqiI_j6InMrE4oF1pCDcsZ05xi2lea7nK8x51PrOU-6eKkbygiVORVz4cL4 align="left")

After some minutes, you can go to the Frontend repository in the Runners section.

You will be able to see your runner is ready to run your pipeline

![](https://lh7-us.googleusercontent.com/4CXQI8WhLedqd6Lo6K0fxqFXlFarOP_ToaVkTQaxKbhmJaM37fH-A4ydfkEVH-zpnaeKv0P1H9wslSR5DGjSWtxkkae29smatzBIxmF6UnrIGP-pKeFDtiUmuDIJIfq46EvVi4K_FqYm812I5IVEYJM align="left")

Now, push the frontend code to the repository

![](https://lh7-us.googleusercontent.com/9tdAAstR4A33Tr2J1wGD3BJxXEA0rwRrnczeiyacUmSm_tns4i_ojHQ8XGA5jPbamW0334iTP09N0E6Fvr7i259Q9ZEusoinCMjUYyHlcEFzsVWa6i40zx_cQRXf-dud32bUX6c76cRkCqhdpRMimtE align="left")

The Pipeline will automatically start as you can see in the below snippet. Our Pipeline was completed successfully.

![](https://lh7-us.googleusercontent.com/PrVKf7LhJpSPPr7E7G-TkePWAj_yZ-7oodv3WiE98iwK-nFJfZt9C07NpD4VWJ1vz62PIT8F_kyvIbzB9zai6YGD8l6yXQ3rmhNjrxEf0mKGvwDnbXYd-l3SkXvR_XKHN_tLysYEgDuLpKMW86PcC5c align="left")

Green Mangoes

![](https://lh7-us.googleusercontent.com/RW3Gw_6lgSwwkr1QBt5xRb9fiYH87y1tsGoz2sQub7FTsdccKjtfhqe0BH48VKCAIWqbrf-od2zZ4ItoENepiFSeT0EcympuPlUyU-Oqgr86eN4dLB2RnnvvwpCDraxxF7NRPCTZZ0rxmWqryCGwK9g align="left")

You can validate your pipeline by going to the manifests repository and in that, the Frontend folder has deployment which should be updated.

If it’s not then, there is something suspicious with your steps

![](https://lh7-us.googleusercontent.com/8arGwZSVehcpRqlX-xasPhv4seYIX1KYbyFV12HgMXuDJdkXUgJ4Tambas5YOn1EbWg-X5IDnUUfgzH06fYEJoXM4bgO3p3Xwkk9DUSaQtjYrG7ta9y87k3dT3lUAIHOj2rNBVbvwTWy7DYm9di4SsI align="left")

Now, you can see your Code smells and vulnerabilities in your frontend Sonarqube Project

![](https://lh7-us.googleusercontent.com/YxIFP97hiCP1UXCUa8kypMHw_igrdLxiTwR0pPl5jKqvpyukIolUATNHvy_nF_N-Ok0-UlVHyFBAhNh7AXQydrGkkMHw28myAadsG0brmP8NvOV4B5izBcF4eFXpGG2-1f--rWKC0-ou64yJTvbzYA4 align="left")

Now, we need to set up fluxCD to deploy our application without any human intervention

Install fluxCD on Gitlab VM

```abap
curl -s https://fluxcd.io/install.sh | sudo bash
```

![](https://lh7-us.googleusercontent.com/aAHGsieK-M2MTQWslsa6UNdJ7ypIMmnbFqCobQVw0Z7Z806WsBmPYZYWmOFOMdKngL0TMPnpBxcBm7unApcJw3Zo2K1fcPvD9jKLImUN9qdN8Lox4dG4PtBZlCEINgJeiHCbNfSvLEsO7K7sqE6L8RM align="left")

Validate whether fluxCD is installed or not

```abap
flux --help
```

![](https://lh7-us.googleusercontent.com/7cnwYwHrzGnIxDP-tImLJInnr0RcbQl_XNZmQJ-jr5JeBq4njQ2hhLgRmimshmFIQhynI8m9JcqkmNk02oolzzIOvuWJFeufCyPGnhWu3CKzkrpmlnUX3iDgqZatRHweS_Slyo1zKZjOf1KQ2hy_xUo align="left")

Check whether the prerequisites for fluxCD are present or not

```abap
flux check --pre
```

![](https://lh7-us.googleusercontent.com/QbpfWzzEQV3gd0xD1rGopi1F15G7T4_MyGgNO6Tt0pAsKsZoW4wwKLI4bk2GEvwGHYTP91QACkCNqOx15n-SJxkaT_MNdjYRu0IqH7-vBSz_sTiF9LTRFPH2XC-Q4A82JkFbDaSoqPSqda-1BAYIBMc align="left")

Now, export the gitlab token

```abap
export GITLAB_TOKEN=<PAT>
```

![](https://lh7-us.googleusercontent.com/FaZq7KLNOtzbyBveDdxjIjTzoHJBagTq_9SJGFw4q7hcp_RiSlvVl02tWxTybSFLOwlM3hwCkGFVP_ZXGkrT9WOqK90F1DJwNSMGDrQAqCb4Crm5k-5b-wL8qtNwy_E631L_ZgHu3tu77BbYhC34pkc align="left")

Now, If you don’t know how fluxCD works. I’ll just give you a high overview

As you know, whenever there are any new changes made to any manifest file. It will be automatically deployed by fluxCD.

Now, The important thing is how fluxCD will get to know that there is any update in the manifest file.

For that, flux created a repository in your Gitlab which will continuously monitor the target repository where your manifest files are located. It is called bootstrapping.

Now, we will be going to Bootstrap which will create a repository. I can choose in which Project, the fluxCD repository will be created by specifying the owner

```abap
flux bootstrap gitlab \
  --deploy-token-auth \
  --owner=azure-devsecops-project/kubernetes-manifests \ # Provide the Project and where do you want to create the fluxCD repository
  --repository=flux-config \ # This will create a repository in which flux will keep it’s configurations
  --branch=main \
  --path=clusters/my-cluster
```

![](https://lh7-us.googleusercontent.com/O5Ry7Mhuq8ucK0bxnujHzNL0uIIC5fxPFdaJabC3dw6-u0k32GnUto8H-aSWEohXWAypT_fmVDgBHgJ2V4m1m2a5LW_0vqpamirO6fHttcjv5IAn6WEYJxunrHbTWiNS_4LFuXIpDIk7trYYWOZYYRw align="left")

Go to Gitlab and Navigate to Azure-DevSecOps-Project group. Then, Go to the Kubernetes-Manifests subgroup. You will see one flux-config repository has been created fluxCD

![](https://lh7-us.googleusercontent.com/phImfMo_AOGpUlHy10SgpnDLF_WZDB1oqQMHv_cAfUaR6yH0fBGb-yw28Tf4aU0oLpmC4PVYXTTM2oKxw9KQIGzlz-LU3ckeCB7iStJvSoFA5wqFZ7R5aSKfQLeLhxrDZmWTF0YMKTPyhRSvwsEcKQE align="left")

Go to that repository and check the content

![](https://lh7-us.googleusercontent.com/AWPnfrqJYfRXtXCTRxO74Wkho6SI4rBqcYhfrczsgbhbI3i1bIKttUg3Fda6k4a58nktGFsdwZU8HwFoWc_00pEpEGBxrMSQi6VwRMSwfRV-ddsWrGsYY-7qvrXuFrlC3-NhlVMqJiv6Gte2LDaUTco align="left")

Now, we need to create a deployment token to access the repository where our Manifest files are stored

Go to **Manifests repository** and navigate to **Settings**\-&gt; Repository and provide the things showing in the below snippet

![](https://lh7-us.googleusercontent.com/m5zpQ90rQLeQ0ITarLU94rpeIUUdNnB4GDVD7rLsno6aXRHgMDid5BV4pXYc928oxqJ5kLJ_sgKCQCocSPHP9GlJuEPOmTPbPvpAkfJQ3GfJNooeE-uETzBQ8UKQ5ETYWtWbjcLSo2fDOv2lRvihbC0 align="left")

Copy the username and token

![](https://lh7-us.googleusercontent.com/abePGHX15ZVzXT5WVATIr7I3-TKZUtTK1OtrTm0eV2OJVuF-sHKxJGtZxVK4I5OhpJGI5FfozFk9JJ258JKS9BcjvypTuoUpNscCEgHskIVpUljqySKwMlM1LiKYga9YbQYMljb9gh3I6Icp5Qzvm64 align="left")

Create a secret by running the below command

```abap
flux create secret git flux-deploy-authentication \  --url=https://gitlab.com/end-to-end-azure-kubernetes-three-tier-project/kubernetes-manifests/manifests \
  --namespace=flux-system \
  --username=<USERNAME> \
  --password=<PASSWORD>
```

![](https://lh7-us.googleusercontent.com/yMeFnlJTkIs_vI5Y2ipLC05LOKyXjKo68wdqpfXadGOmm86xqixuO_bCA-kIhDVxstHOSF_hgjO9jH0NEiWxcvRf1_8P_zyhssBHlL8lpzBTxW2iA1DXbNgJefr5Z4I9vOuEs13pFwd6AZ9CB4SP3Bg align="left")

Validate the secrets by running the below command

```abap
kubectl -n flux-system get secrets flux-deploy-authentication -o yaml
```

![](https://lh7-us.googleusercontent.com/oDf-Ge1b4Si2UwH3Qr_ZjB2mlHyJUcuoL--1HXZjpuO9Mo2BHPlV3rTmBVfUIBwv52gEzn7nPeN3Dj8eag9I2G2ghZ4hqD1QafEU9H3nF79mNKJRHGyfD4gqrbT_tc9y24Alz6aEwURHvU_AeVmkze4 align="left")

Now, we need to provide some custom YAML files to deploy our Manifest file in the flux-config repository.

To do that, clone the flux-config repository in your VS code

![](https://cdn-images-1.medium.com/max/880/0*sgJTSEP2cHebi0hB align="left")

Create a yaml file named source-manifest.yaml to sync with the manifest repo (This won’t apply to the manifest file) in the my-cluster path

***Note****: In the URL section, you need to provide the repository link where your Manifests files are stored*

![](https://lh7-us.googleusercontent.com/4soJSFfJ-qRcfvtjKgs0cyocTDct8HZ7mWRXyfMW8AF3x-NzBxehwIZBqW1VgEn8GET9R-2IiS0BwW_TMeq4b6YlloHDuI_P7v8cj6ViMBCDcFlsn1qVkZYQ3Ue2rS3L08vtOmLdzgglgsrnxiVDRTw align="left")

Now, we need to create the second yaml which is kustomization resource that informs flux to sync the manifest file deployment which is defined in the source-manifest yaml file

***Note:*** *I have three folders in my manifest file. FluxCD won’t be able to deploy all those manifest files in one go. For that, we need to create a kustomization resource for each folder and it’s good practice to avoid any confusion because the folders are dedicated to tiers such as Frontend, Database, and Application.* ***Kindly go through all the files*** *that we are going to create from here. Otherwise, you can get errors and that can take a lot of minutes*

This is for database folder, we have some manifests file in Database folder which will deploy by fluxCD

![](https://lh7-us.googleusercontent.com/BfDj1NOhocLUMb0qkgQE42BJome1w4ZJhB2_FyeixqKpMG_6Dng7PFOigAQOAo5rQoAdr0IgWPvAHCCkmZzGUAWWDJFG6yNvQtVMezVNDA6dotE1dae5WenSrXWQ-AGPvwMilYWs1uXcowimdConMgo align="left")

Now, we will create kustomization resource for the Backend folder

![](https://cdn-images-1.medium.com/max/880/0*d20zDCM89k9dP8K3 align="left")

We will create kustomization resource for the Frontend folder

![](https://lh7-us.googleusercontent.com/RTLlTdbvkIuXnl-Oc82qvahC3Ljdvk0o6GBp9JsAbOoS4Lpagp4wS7v_3fIoCIHL773lJPy3UVfMoey8SY5glVTefCGaI-mc66s9iuugNJpLK80USe_diRczuoRPfuApWXlC0_5UgleGUctJ5wbKQjs align="left")

Now, in the end, we have an ingress file that is not stored in any folder.

So, we will create one kustomization resource for it as well

![](https://lh7-us.googleusercontent.com/JwRGZhb7E50xnVqvbYd0RyKNOGjd-J1LOagcLBZz-pchP7y3_TFtRS2MP5Zoq6A6_uT9g6YkqNA5dc-V2O4RvK8oDfDjDJ19hCSoLIJxUB7JN2jugOjQ1wuBqEaLznGgIvvwtMK4sKF-7e4L5Psq-B0 align="left")

Now, We need to push these changes to the Gitlab repo. But before that, go to your Kubernetes cluster and create a three-tier namespace by using the below command

```abap
kubectl create ns three-tier
```

![](https://lh7-us.googleusercontent.com/IcT3ChEG_DMEKdnW2CXXs9lu1evifOVVK0d0YLb9CTaZEbEmWZj6s9sFstVxhp1bl3rUj9GTdKq0dggRDuKCHoqvTQlGmE433B_jw9EiIs5ra78nAdV3ks6JlwwEAXpHQY3Xp1_KfWfKfReSAd3ZUlQ align="left")

Now, Push the changes to the Gitlab repo

![](https://lh7-us.googleusercontent.com/NixRLLmG74d9aVsuX1XuHiD-ltLcONaJKtcWEP_87AG92GyHJb1wUZZ7TEv1ItbQHVoHTmiRnVBWdNGvJ5fF7GtLsV5s7XALqirokkyoqnrRBoS2EiUhgbT-k7n9xKUEHY9ppN7RAy4mCV7PGpZXj_U align="left")

Once you push the changes to the repo, fluxCD will automatically deploy your manifests file to the Kubernetes Cluster

You can list all the objects that are created in the three-tier namespace by running the below command

```abap
kubectl get all -n three-tier
```

![](https://cdn-images-1.medium.com/max/880/0*cVpcaZLzUyVuDvbh align="left")

Ingress won’t appear if you run the ‘get all’ command. You need to write the below command to get ingress

```abap
kubectl get ing -n three-tier
```

The above command will show you the address for ingress which you need to add in your domain provider to correspondent to your hosts

![](https://lh7-us.googleusercontent.com/Cko8ncr3a45-b8jQmY4W8J7o4h4DhH1FYsbQapqARX5i6R3dJu-qQ3ckT9DIxa3IgR1oOnHMpo5SJkMv-Bd3D6hjQE7U_YEsgAvQRf0lXIjRUPxr4mce2RaJabWpxU1F6NIUupA3rnp3lO-PqK_ZhmI align="left")

This is my domain provider, I have added the public IP given by Ingress in the same hosts that are written in the Ingress file.

![](https://lh7-us.googleusercontent.com/pqxqjeDZxVolsX9S8k9SGq0_758EzLlp11fNEdWiMXuN4PpLfGPju_jDD1qmS-N-GJn2YIwOJm5U2O4QyJZXW1fvVKQG3zvkk55u2uHlZBy352PECDz3PND4OVSESRaE0YYbDeqmpsXrvq1s10CYRiA align="left")

Hit the hostname from your favorite browser and

Congratulations You have successfully deployed the application on Azure AKS using GitLab DevSecOps Pipeline and fluxCD

![](https://lh7-us.googleusercontent.com/zNDral0rYkKi1VIsbaYknSNcKqNWjW9EpOyxfkSEuBbRQsf0v70CPsF_ijWuozIeuQEZr4JEznPAejyKI16GAwrFB0j01pEs1oXtfLIBg9LJT_K1DSIguwhf4n1y8M498e1jaHal0PEZW0oOgIEMZc0 align="left")

Now, Just Re-run the both pipelines again(backend & frontend). We are expecting the new image will be pushed to the ACR which updates in the deployment file as well. Then, fluxCD will get the update and deploy the updated deployment file

We have also implemented manual image updation which the last stage won’t run automatically. To run it, you need to give permission(click on the Play button)

![](https://lh7-us.googleusercontent.com/RWmiKRLUQXeUj_-fABR7qb_ZRhGW3kVnAiYpMTXqg0-Apq0_Nk-0Gl6p8zHTPNY0WdRD5OY6rDM_D-wxFnj-saW2cYyTJHWwsjHWlRwsmgk8SdbdatvozasMw89Sr5tKyDMYX6hdGpwUd_0mE5s9OeQ align="left")

You can go to Grafana Dashboard and see the number of pods running and other stuff like CPU usage, etc.

![](https://lh7-us.googleusercontent.com/YmyszHw-b3tSgwGKZiW0rEvxknySjGKb1UgC-yCAR_KuU9mFqPQdijhLNQNHSPkV4hPluPSfw9gqUoblI4vQedUmtWioFLnO6HUutWtQhVzTZKbwU1aBrry79szGBoqu8m-vD18zpV_ireaGjCXW_So align="left")

If you have implemented this project till the end then, Congratulations. It means you have completed this Project

### **CleanUp**

Once you completed the deployment and all the other things. Don’t forget to clean up the resources

Follow the below steps to clean the resources

* You need to run the pipeline of azure-aks which will delete the AKS Cluster. Once you run the pipeline, you need to provide the value of the TERRAFORM\_ACTION variable which will be destroyed. This will destroy your AKS Cluster. But if you get an error in your plan stage like an invalid role ID and secret ID. Then, log in to the hashicorp vault server. Delete the previous app role and regenerate the role ID and secret ID as we did earlier. Then, you need to update your AKS repository variables in which VAULT\_ROLE\_ID and VAULT\_SECRET\_ID values you need to change. Now, run the pipeline again and this will destroy the AKS without getting any error.
    
* Now, you need to destroy the hashicorp vault server. To do that, go to your hashicorp vault repository and run the pipeline along with the variable TERRAFORM\_ACTION value destroy. This will destroy the hashicorp VM.
    
* After that, you need to destroy the Gitlab VM. To do that, go to the gitlab-vm repository and run the pipeline along with the variable TERRAFORM\_ACTION value destroy. This will destroy your gitlab-vm as well
    
* All the things were cleaned up. But if you are going to write a blog and you are going to post on public forums. Then, delete all the Personal Access tokens such as Docker PAT, Gitlab PAT, and other confidential information
    

---

### Conclusion

In conclusion, the integration of Terraform, HashiCorp Vault, and GitLab CI/CD pipelines provides a powerful framework for automating and managing cloud infrastructure deployments on Azure. By following the outlined steps and best practices, organizations can establish a scalable, secure, and efficient DevOps workflow. Empowered with the ability to provision infrastructure as code and manage secrets securely, teams can accelerate their development cycles, improve collaboration, and deliver reliable applications with confidence in the cloud-native era.

Stay connected on **LinkedIn**: [LinkedIn Profile](https://www.linkedin.com/in/aman-devops/)

Stay up-to-date [with **GitHub**: Git](https://www.linkedin.com/in/aman-devops/)[Hub Profile](https://github.com/AmanPathak-DevOps)

[Feel free to re](https://www.linkedin.com/in/aman-devops/)[ach out to me](https://github.com/AmanPathak-DevOps), if you have [any other quer](https://github.com/AmanPathak-DevOps)ies.

Happy Learning!